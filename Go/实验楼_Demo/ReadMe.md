---
title: GoåŸºç¡€
source: å®éªŒæ¥¼
---

# Goè¯­è¨€é¡ºåºç¼–ç¨‹

## æµç¨‹æ§åˆ¶

Go è¯­è¨€æä¾›çš„æµç¨‹æ§åˆ¶è¯­å¥åŒ…æ‹¬ `if`ã€`switch`ã€`for`ã€`goto`ã€`select`ï¼Œå…¶ä¸­ `select` ç”¨äºç›‘å¬ `channel`ï¼ˆé€šé“ï¼‰åœ¨è®²è§£é€šé“çš„æ—¶å€™å†è¯¦ç»†ä»‹ç»ã€‚

### if è¯­å¥

è¯­æ³•ï¼š

```go
if optionalStatement1; booleanExpression1 {
    block1
} else if optionalStatement2; booleanExpression2 {
    block2
} else {
    block3
}
```

å…¶ä¸­ `optionalStatement` æ˜¯å¯é€‰çš„è¡¨è¾¾å¼ï¼ŒçœŸæ­£å†³å®šåˆ†æ”¯èµ°å‘çš„æ˜¯ `booleanExpression1` çš„å€¼ã€‚

### if è¯­å¥

è¯­æ³•ï¼š

```go
if optionalStatement1; booleanExpression1 {
    block1
} else if optionalStatement2; booleanExpression2 {
    block2
} else {
    block3
}
```

å…¶ä¸­ `optionalStatement` æ˜¯å¯é€‰çš„è¡¨è¾¾å¼ï¼ŒçœŸæ­£å†³å®šåˆ†æ”¯èµ°å‘çš„æ˜¯ `booleanExpression1` çš„å€¼ã€‚

### for è¯­å¥

Go è¯­è¨€çš„  `for` è¯­å¥å¯ä»¥éå†æ•°ç»„ï¼Œåˆ‡ç‰‡ï¼Œæ˜ å°„ç­‰ç±»å‹ï¼Œä¹Ÿå¯ä»¥ç”¨äºæ— é™å¾ªç¯ã€‚ä»¥ä¸‹æ˜¯å…¶è¯­æ³•ï¼š

```go
for { // æ— é™å¾ªç¯
    block
}

for booleanExpression { // whileå¾ªç¯ï¼Œåœ¨Goè¯­è¨€ä¸­æ²¡æœ‰whileå…³é”®å­—

}

for index, char := range aString { // è¿­ä»£å­—ç¬¦ä¸²

}

for item := range aChannel { // è¿­ä»£é€šé“

}
```

### è·³è½¬è¯­å¥

Go è¯­è¨€ä¸­ä½¿ç”¨ `goto` å…³é”®å­—å®ç°è·³è½¬ã€‚`goto` è¯­å¥çš„è¯­ä¹‰éå¸¸ç®€å•ï¼Œå°±æ˜¯è·³è½¬åˆ°æœ¬å‡½æ•°å†…çš„æŸä¸ªæ ‡ç­¾ï¼Œä¾‹å¦‚ï¼š

```go
func myfunc(){
    i := 0
    THIS: //å®šä¹‰ä¸€ä¸ªTHISæ ‡ç­¾
    fmt.Println(i)
    i++
    if i < 1 {
        goto THIS //è·³è½¬åˆ°THISæ ‡ç­¾
    }
}
```

### switchè¯­å¥

Go è¯­è¨€ä¸­ `switch` åˆ†æ”¯æ—¢å¯ç”¨äºå¸¸ç”¨çš„åˆ†æ”¯å°±åƒ C è¯­è¨€ä¸­çš„ `switch` ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥ç”¨äºç±»å‹å¼€å…³ï¼Œæ‰€è°“ç±»å‹å¼€å…³å°±æ˜¯ç”¨äºåˆ¤æ–­å˜é‡å±äºä»€ä¹ˆç±»å‹ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ Go è¯­è¨€çš„ `switch` è¯­å¥ä¸ä¼šè‡ªåŠ¨è´¯ç©¿ï¼Œç›¸åï¼Œå¦‚æœæƒ³è¦è´¯ç©¿éœ€è¦æ·»åŠ  `fallthrough` è¯­å¥ã€‚è¡¨è¾¾å¼å¼€å…³ `switch` çš„è¯­æ³•å¦‚ä¸‹ï¼š

```go
switch optionalStatement; optionalExpression {
    case expression1: block1
    ...
    case expressionN: blockN
    default: blockD
}
```

ä¸‹é¢æ˜¯ä¸ªä¾‹å­ï¼š

```go
switch {        // æ²¡æœ‰è¡¨è¾¾å¼ï¼Œé»˜è®¤ä¸ºTrueå€¼ï¼ŒåŒ¹é…åˆ†æ”¯ä¸­å€¼ä¸ºTrueçš„åˆ†æ”¯
    case value < minimum:
        return minimum
    case value > maximum:
        return maximum
    default:
        return value
}
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œswitch åé¢æ²¡æœ‰é»˜è®¤çš„è¡¨è¾¾å¼ï¼Œè¿™ä¸ªæ—¶å€™ Go è¯­è¨€é»˜è®¤å…¶å€¼ä¸º `True`ã€‚

åœ¨å‰é¢æˆ‘ä»¬æåˆ°è¿‡ç±»å‹æ–­è¨€ï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“å˜é‡çš„ç±»å‹å°±å¯ä»¥ä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œä½†æ˜¯å½“æˆ‘ä»¬çŸ¥é“ç±»å‹å¯èƒ½æ˜¯è®¸å¤šç±»å‹ä¸­çš„ä¸€ç§æ—¶å€™ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ç±»å‹å¼€å…³ã€‚å…¶è¯­æ³•å¦‚ä¸‹ï¼š

```go
switch optionalStatement; typeSwitchGuard {
    case type1: block1
    ...
    case typeN: blockN
    default: blockD
}
```

è¯´äº†è¿™ä¹ˆå¤šï¼Œè®©æˆ‘ä»¬è¿›è¡Œä¸‹ç»ƒä¹ ï¼Œåˆ›å»ºæºæ–‡ä»¶ `switch_t.go`ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

ğŸ˜ğŸ˜<b>è¿™ä¸ªdemoå¾ˆé‡â—â—â—â—â—â—â—</b>>ğŸ˜ğŸ˜

```go
 
```

ä»¥ä¸Šä»£ç ä¸­æˆ‘ä»¬é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªæ¥æ”¶ä»»æ„æ•°é‡ä»»æ„ç±»å‹å‚æ•°çš„å‡½æ•°ï¼Œç„¶åä½¿ç”¨ `for ... range aSlice` çš„è¯­æ³•è¿­ä»£äº†æ¯ä¸€ä¸ªåœ¨åˆ‡ç‰‡ `items` ä¸­çš„å…ƒç´ ï¼Œæ¥ç€ä½¿ç”¨äº† `switch` ç±»å‹å¼€å…³åˆ¤æ–­äº†æ¯ä¸€ä¸ªå‚æ•°çš„ç±»å‹ï¼Œå¹¶æ‰“å°äº†å…¶å€¼å’Œç±»å‹ã€‚ç¨‹åºè¿è¡Œè¾“å‡ºå¦‚ä¸‹ï¼š

```go
$ go run switch_t.go
param #0 is a int, value: 5
param #1 is a float64, value: -17.980000
param #2 is a string, value: AIDEN
param #3 is a nil
param #4 is a bool, value: true
param #5's type is unknow
```

## å‡½æ•°

Go è¯­è¨€å¯ä»¥å¾ˆæ–¹ä¾¿çš„è‡ªå®šä¹‰å‡½æ•°ï¼Œå…¶ä¸­æœ‰ç‰¹æ®Šçš„å‡½æ•° `main` å‡½æ•°ã€‚`main` å‡½æ•°å¿…é¡»å‡ºç°åœ¨ `main` åŒ…é‡Œï¼Œä¸”åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚å½“ Go ç¨‹åºè¿è¡Œæ—¶å€™ä¼šè‡ªåŠ¨è°ƒç”¨ `main` å‡½æ•°å¼€å§‹æ•´ä¸ªç¨‹åºçš„æ‰§è¡Œã€‚`main` å‡½æ•°ä¸å¯æ¥æ”¶ä»»ä½•å‚æ•°ï¼Œä¹Ÿä¸è¿”å›ä»»ä½•ç»“æœã€‚

### å‡½æ•°çš„å®šä¹‰

åœ¨ Go è¯­è¨€ä¸­ï¼Œå‡½æ•°çš„åŸºæœ¬ç»„æˆåŒ…æ‹¬ï¼šå…³é”®å­— `func`ã€å‡½æ•°åã€å‚æ•°åˆ—è¡¨ã€è¿”å›å€¼ã€å‡½æ•°ä½“å’Œè¿”å›è¯­å¥ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„åŠ æ³•å‡½æ•°æ¥å¯¹å‡½æ•°çš„å®šä¹‰è¿›è¡Œè¯´æ˜ã€‚

```go
package add

func Add(a int, b int) (num int){
    return a + b
}
```

### å‡½æ•°çš„è°ƒç”¨

å‡½æ•°è°ƒç”¨éå¸¸ç®€å•ï¼Œå…ˆå°†è¢«è°ƒç”¨å‡½æ•°æ‰€åœ¨çš„åŒ…å¯¼å…¥ï¼Œå°±å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥å‡½æ•°äº†ã€‚æ³¨æ„éœ€è¦æŠŠåŒ…æ–‡ä»¶å¤¹æ”¾åˆ° `$GOPATH` ç›®å½•ä¸­ï¼Œå®ä¾‹å¦‚ä¸‹ï¼š

```go
package main

import (
    "add" //å¯¼å…¥ add åŒ…
    "fmt"
)

func main(){
    c := add.Add(1, 2) //è°ƒç”¨ add åŒ…ä¸­çš„ add å‡½æ•°
    fmt.Println(c)
}
```

---

ä¸ C/C++ å’Œ JAVA ä¸åŒï¼ŒGo è¯­è¨€çš„å‡½æ•°å’Œæ–¹æ³•å¯ä»¥æœ‰å¤šä¸ªè¿”å›å€¼ï¼Œè¿™æ˜¯ Go æä¾›çš„ä¸€ä¸ªä¼˜ç¾çš„ç‰¹æ€§ï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
package Divide
import "errors"

func divide (a int, b int) (num int, err error){ //å®šä¹‰ä¸¤ä¸ªè¿”å›å€¼
    if b == 0 {
        err = errors.New("è¢«é™¤æ•°ä¸èƒ½ä¸ºé›¶ï¼")
        return
    }
    return a / b, nil   //æ”¯æŒå¤šä¸ªè¿”å›å€¼
}
```

### åŒ¿åå‡½æ•°

åœ¨ Go è¯­è¨€ä¸­ï¼Œä½ å¯ä»¥åœ¨ä»£ç é‡Œéšæ—¶å®šä¹‰åŒ¿åå‡½æ•°ï¼ŒåŒ¿åå‡½æ•°ç”±ä¸€ä¸ªä¸å¸¦å‡½æ•°åçš„å‡½æ•°å£°æ˜å’Œå‡½æ•°ä½“ç»„æˆï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
func (a, b, c int) bool {
    return a * b < c
}
```

ä½ å¯ä»¥å°†åŒ¿åå‡½æ•°ç›´æ¥èµ‹å€¼ç»™ä¸€ä¸ªå˜é‡ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨è¿è¡Œï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
x := func (a, b, c int) bool {
    return a * b < c
}

func (a, b, c int) bool {
    return a * b < c
} (1, 2, 3) //å°æ‹¬å·å†…ç›´æ¥ç»™å‚æ•°åˆ—è¡¨è¡¨ç¤ºå‡½æ•°è°ƒç”¨
```

## ç±»å‹è½¬æ¢

### ç±»å‹è½¬æ¢

Go è¯­è¨€æä¾›äº†ä¸€ç§åœ¨ä¸åŒä½†ç›¸äº’å…¼å®¹çš„ç±»å‹ä¹‹é—´ç›¸äº’è½¬æ¢çš„æ–¹å¼ï¼Œè¿™ç§è½¬æ¢éå¸¸æœ‰ç”¨å¹¶ä¸”æ˜¯å®‰å…¨çš„ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯åœ¨æ•°å€¼ä¹‹é—´è¿›è¡Œè½¬æ¢å¯èƒ½é€ æˆå…¶ä»–é—®é¢˜ï¼Œå¦‚ç²¾åº¦ä¸¢å¤±æˆ–è€…é”™è¯¯çš„ç»“æœã€‚ä»¥ä¸‹æ˜¯ç±»å‹è½¬æ¢çš„è¯­æ³•ï¼š

- `resultOfType := Type(expression)`

å‡ ä¸ªä¾‹å­ï¼š

```go
x := int16(2345)        // å£°æ˜ä¸€ä¸ªç±»å‹ä¸ºint16çš„æ•´æ•°ï¼Œå…¶å€¼ä¸º2345
y := int32(x)           // å°†int16ç±»å‹çš„æ•´æ•°è½¬æ¢ä¸ºint32ç±»å‹
a := uint16(65000)       // å£°æ˜ä¸€ä¸ªç±»å‹ä¸ºuint16ç±»å‹çš„æ•´æ•°
b := int16(a)           // è½¬æ¢ä¸ºint16ç±»å‹ï¼Œè™½ç„¶èƒ½è½¬æ¢æˆåŠŸï¼Œä½†æ˜¯ç”±äº65000è¶…è¿‡in16ç±»å‹çš„èŒƒå›´ï¼Œä¼šå¯¼è‡´ç»“æœé”™è¯¯ï¼Œbçš„å€¼ä¸º -536
```

å¦å¤–åœ¨ Go è¯­è¨€ä¸­å¯ä»¥é€šè¿‡ `type` å…³é”®å­—å£°æ˜ç±»å‹ï¼Œå¦‚ `type StringsSlice []string` å°† `[]string`ï¼ˆ`string` ç±»å‹çš„åˆ‡ç‰‡ï¼‰å£°æ˜ä¸º `StringSlice` ç±»å‹ã€‚

### ç±»å‹æ–­è¨€

è¯´åˆ°ç±»å‹æ–­è¨€å°±éœ€è¦å…ˆäº†è§£ä¸‹ Go è¯­è¨€ä¸­çš„æ¥å£ã€‚åœ¨ Go è¯­è¨€ä¸­æ¥å£æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹ã€‚å®ƒå£°æ˜äº†ä¸€ä¸ªæˆ–è€…å¤šä¸ªæ–¹æ³•ã€‚ä»»ä½•å®ç°äº†è¿™äº›æ–¹æ³•çš„å¯¹è±¡ï¼ˆç±»å‹ï¼‰éƒ½æ»¡è¶³è¿™ä¸ªæ¥å£ã€‚

æ¥å£æ˜¯å®Œå…¨æŠ½è±¡çš„ï¼Œä¸èƒ½å®ä¾‹åŒ–ã€‚`interface{}` ç±»å‹è¡¨ç¤ºä¸€ä¸ªç©ºæ¥å£ï¼Œä»»ä½•ç±»å‹éƒ½æ»¡è¶³ç©ºæ¥å£ã€‚ä¹Ÿå°±æ˜¯è¯´ `interface{}` ç±»å‹çš„å€¼å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ Go è¯­è¨€ç±»å‹çš„å€¼ã€‚

è¿™é‡Œçš„ç©ºæ¥å£æœ‰ç‚¹ç±»ä¼¼äº Python è¯­è¨€ä¸­çš„ object å®ä¾‹ã€‚æ—¢ç„¶ `interface{}` å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ç±»å‹ï¼Œé‚£æœ‰çš„æ—¶å€™æˆ‘ä»¬éœ€è¦å°† `interface{}` ç±»å‹è½¬æ¢ä¸ºæˆ‘ä»¬éœ€è¦çš„ç±»å‹ï¼Œè¿™ä¸ªæ“ä½œç§°ä¸ºç±»å‹æ–­è¨€ã€‚

**ä¸€èˆ¬æƒ…å†µä¸‹åªæœ‰æˆ‘ä»¬å¸Œæœ›è¡¨è¾¾å¼æ˜¯æŸç§ç‰¹å®šç±»å‹çš„å€¼æ—¶æ‰ä½¿ç”¨ç±»å‹æ–­è¨€**ã€‚Go è¯­è¨€ä¸­å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¯­æ³•ï¼š

- `resultOfType, boolean := expression.(Type)`ï¼šå®‰å…¨çš„ç±»å‹æ–­è¨€ã€‚
- `resultOfType := expression.(Type)`ï¼šéå®‰å…¨çš„ç±»å‹æ–­è¨€ï¼Œå¤±è´¥æ—¶ç¨‹åºä¼šäº§ç”Ÿå¼‚å¸¸ã€‚

åˆ›å»ºæºæ–‡ä»¶ `type_t.go`ï¼Œè¾“å…¥ä»¥ä¸‹æºæ–‡ä»¶ï¼š

```go
package main

import (
    "fmt"
)

func main() {
    x := uint16(65000)
    y := int16(x) // å°† xè½¬æ¢ä¸ºint16ç±»å‹
    fmt.Printf("type and value of x is: %T and %d\n", x, x) // %T æ ¼å¼åŒ–æŒ‡ä»¤çš„ä½œç”¨æ˜¯è¾“å‡ºå˜é‡çš„ç±»å‹
    fmt.Printf("type and value of y is: %T and %d\n", y, y)

    var i interface{} = 99 // åˆ›å»ºä¸€ä¸ªinterface{}ç±»å‹ï¼Œå…¶å€¼ä¸º99
    var s interface{} = []string{"left", "right"}
    j := i.(int) // æˆ‘ä»¬å‡è®¾iæ˜¯å…¼å®¹intç±»å‹ï¼Œå¹¶ä½¿ç”¨ç±»å‹æ–­è¨€å°†å…¶è½¬æ¢ä¸ºintç±»å‹
    fmt.Printf("type and value of j is: %T and %d\n", j, j)

    if s, ok := s.([]string); ok { // åˆ›å»ºäº†å½±å­å˜é‡ï¼Œifçš„ä½œç”¨åŸŸä¸­è¦†ç›–äº†å¤–éƒ¨çš„å˜é‡s
        fmt.Printf("%T -> %q\n", s, s)
    }
}
```

è¿è¡Œç¨‹åºï¼š

```bash
$ go run type_t.go
type and value of x is: uint16 and 65000
type and value of y is: int16 and -536
type and value of j is: int and 99
[]string -> ["left" "right"]
```

### ç±»å‹æ–­è¨€

è¯´åˆ°ç±»å‹æ–­è¨€å°±éœ€è¦å…ˆäº†è§£ä¸‹ Go è¯­è¨€ä¸­çš„æ¥å£ã€‚åœ¨ Go è¯­è¨€ä¸­æ¥å£æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹ã€‚å®ƒå£°æ˜äº†ä¸€ä¸ªæˆ–è€…å¤šä¸ªæ–¹æ³•ã€‚ä»»ä½•å®ç°äº†è¿™äº›æ–¹æ³•çš„å¯¹è±¡ï¼ˆç±»å‹ï¼‰éƒ½æ»¡è¶³è¿™ä¸ªæ¥å£ã€‚

æ¥å£æ˜¯å®Œå…¨æŠ½è±¡çš„ï¼Œä¸èƒ½å®ä¾‹åŒ–ã€‚`interface{}` ç±»å‹è¡¨ç¤ºä¸€ä¸ªç©ºæ¥å£ï¼Œä»»ä½•ç±»å‹éƒ½æ»¡è¶³ç©ºæ¥å£ã€‚ä¹Ÿå°±æ˜¯è¯´ `interface{}` ç±»å‹çš„å€¼å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ Go è¯­è¨€ç±»å‹çš„å€¼ã€‚

è¿™é‡Œçš„ç©ºæ¥å£æœ‰ç‚¹ç±»ä¼¼äº Python è¯­è¨€ä¸­çš„ object å®ä¾‹ã€‚æ—¢ç„¶ `interface{}` å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ç±»å‹ï¼Œé‚£æœ‰çš„æ—¶å€™æˆ‘ä»¬éœ€è¦å°† `interface{}` ç±»å‹è½¬æ¢ä¸ºæˆ‘ä»¬éœ€è¦çš„ç±»å‹ï¼Œè¿™ä¸ªæ“ä½œç§°ä¸ºç±»å‹æ–­è¨€ã€‚

**ä¸€èˆ¬æƒ…å†µä¸‹åªæœ‰æˆ‘ä»¬å¸Œæœ›è¡¨è¾¾å¼æ˜¯æŸç§ç‰¹å®šç±»å‹çš„å€¼æ—¶æ‰ä½¿ç”¨ç±»å‹æ–­è¨€**ã€‚Go è¯­è¨€ä¸­å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¯­æ³•ï¼š

- `resultOfType, boolean := expression.(Type)`ï¼šå®‰å…¨çš„ç±»å‹æ–­è¨€ã€‚
- `resultOfType := expression.(Type)`ï¼šéå®‰å…¨çš„ç±»å‹æ–­è¨€ï¼Œå¤±è´¥æ—¶ç¨‹åºä¼šäº§ç”Ÿå¼‚å¸¸ã€‚

åˆ›å»ºæºæ–‡ä»¶ `type_t.go`ï¼Œè¾“å…¥ä»¥ä¸‹æºæ–‡ä»¶ï¼š

```go
package main

import (
    "fmt"
)

func main() {
    x := uint16(65000)
    y := int16(x) // å°† xè½¬æ¢ä¸ºint16ç±»å‹
    fmt.Printf("type and value of x is: %T and %d\n", x, x) // %T æ ¼å¼åŒ–æŒ‡ä»¤çš„ä½œç”¨æ˜¯è¾“å‡ºå˜é‡çš„ç±»å‹
    fmt.Printf("type and value of y is: %T and %d\n", y, y)

    var i interface{} = 99 // åˆ›å»ºä¸€ä¸ªinterface{}ç±»å‹ï¼Œå…¶å€¼ä¸º99
    var s interface{} = []string{"left", "right"}
    j := i.(int) // æˆ‘ä»¬å‡è®¾iæ˜¯å…¼å®¹intç±»å‹ï¼Œå¹¶ä½¿ç”¨ç±»å‹æ–­è¨€å°†å…¶è½¬æ¢ä¸ºintç±»å‹
    fmt.Printf("type and value of j is: %T and %d\n", j, j)

    if s, ok := s.([]string); ok { // åˆ›å»ºäº†å½±å­å˜é‡ï¼Œifçš„ä½œç”¨åŸŸä¸­è¦†ç›–äº†å¤–éƒ¨çš„å˜é‡s
        fmt.Printf("%T -> %q\n", s, s)
    }
}
```

è¿è¡Œç¨‹åºï¼š

```bash
$ go run type_t.go
type and value of x is: uint16 and 65000
type and value of y is: int16 and -536
type and value of j is: int and 99
[]string -> ["left" "right"]
```

## é”™è¯¯å¤„ç†

é”™è¯¯å¤„ç†æ˜¯ä»»ä½•è¯­è¨€éƒ½éœ€è¦è€ƒè™‘åˆ°çš„é—®é¢˜ï¼Œè€Œ Go è¯­è¨€åœ¨é”™è¯¯å¤„ç†ä¸Šè§£å†³å¾—æ›´ä¸ºå®Œå–„ï¼Œä¼˜é›…çš„é”™è¯¯å¤„ç†æœºåˆ¶æ˜¯ Go è¯­è¨€çš„ä¸€å¤§ç‰¹ç‚¹ã€‚

### error

Go è¯­è¨€å¼•å…¥äº†ä¸€ä¸ªé”™è¯¯å¤„ç†çš„æ ‡å‡†æ¨¡å¼ï¼Œå³ `error` æ¥å£ï¼Œè¯¥æ¥å£å®šä¹‰å¦‚ä¸‹ï¼š

```go
type error interface {
    Error() string
}
```

å¯¹äºå¤§å¤šæ•°å‡½æ•°ï¼Œå¦‚æœè¦è¿”å›é”™è¯¯ï¼Œå¯ä»¥å°† `error` ä½œä¸ºå¤šè¿”å›å€¼çš„æœ€åä¸€ä¸ªï¼š

```go
func foo(param int)(ret int, err error)
{
  ...
}
```

è°ƒç”¨æ—¶çš„ä»£ç ï¼š

```go
n, err := foo(0)
if err != nil {
    //  é”™è¯¯å¤„ç†
} else {
    // ä½¿ç”¨è¿”å›å€¼n
}
```

æˆ‘ä»¬è¿˜å¯ä»¥è‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Œåˆ›å»ºæºæ–‡ä»¶ `error.go`ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

```go
package main

import "fmt"
import "errors"

//è‡ªå®šä¹‰çš„å‡ºé”™ç»“æ„
type myError struct {
    arg  int
    errMsg string
}
//å®ç°Erroræ¥å£
func (e *myError) Error() string {
    return fmt.Sprintf("%d - %s", e.arg, e.errMsg)
}

//ä¸¤ç§å‡ºé”™
func error_test(arg int) (int, error) {
    if arg < 0  {
         return -1, errors.New("Bad Arguments - negtive!")
     }else if arg >256 {
        return -1, &myError{arg, "Bad Arguments - too large!"}
    }
    return arg*arg, nil
}

//ç›¸å…³çš„æµ‹è¯•
func main() {
    for _, i := range []int{-1, 4, 1000} {
        if r, e := error_test(i); e != nil {
            fmt.Println("failed:", e)
        } else {
            fmt.Println("success:", r)
        }
    }
}
```

### defer

ä½ å¯ä»¥åœ¨ Go å‡½æ•°ä¸­æ·»åŠ å¤šä¸ª `defer` è¯­å¥ï¼Œå½“å‡½æ•°æ‰§è¡Œåˆ°æœ€åæ—¶ï¼Œè¿™äº› defer è¯­å¥ä¼šæŒ‰ç…§é€†åºæ‰§è¡Œï¼ˆå³æœ€åä¸€ä¸ª `defer` è¯­å¥å°†æœ€å…ˆæ‰§è¡Œï¼‰ï¼Œæœ€åè¯¥å‡½æ•°è¿”å›ã€‚ç‰¹åˆ«æ˜¯å½“ä½ åœ¨è¿›è¡Œä¸€äº›æ‰“å¼€èµ„æºçš„æ“ä½œæ—¶ï¼Œé‡åˆ°é”™è¯¯éœ€è¦æå‰è¿”å›ï¼Œåœ¨è¿”å›å‰ä½ éœ€è¦å…³é—­ç›¸åº”çš„èµ„æºï¼Œä¸ç„¶å¾ˆå®¹æ˜“é€ æˆèµ„æºæ³„éœ²ç­‰é—®é¢˜ã€‚å¦‚ä¸‹ä»£ç æ‰€ç¤ºï¼Œæˆ‘ä»¬ä¸€èˆ¬å†™æ‰“å¼€ä¸€ä¸ªèµ„æºæ˜¯è¿™æ ·æ“ä½œçš„ï¼š

```go
func CopyFile(dst, src string) (w int64, err error) {
    srcFile, err := os.Open(src)
    if err != nil {
        return
    }

    defer srcFile.Close()

    dstFile, err := os.Create(dst)
    if err != nil {
        return
    }

    defer dstFile.Close()

    return io.Copy(dstFile, srcFile)
}
```

å¦‚æœ `defer` åé¢ä¸€æ¡è¯­å¥å¹²ä¸å®Œæ¸…ç†å·¥ä½œï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼š

```go
defer func(){
    ...
}()
```

æ³¨æ„ï¼Œ`defer` è¯­å¥æ˜¯åœ¨ `return` ä¹‹åæ‰§è¡Œçš„ï¼Œæ–°å»ºæºæ–‡ä»¶ `defer.go` è¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

```go
func test() (result int) {
    defer func() {
        result = 12
    }()
    return 10
}

func main() {
    fmt.Println(test())     // 12
}
```

### panic

`panic()` å‡½æ•°ç”¨äºæŠ›å‡ºå¼‚å¸¸ï¼Œ`recover()` å‡½æ•°ç”¨äºæ•è·å¼‚å¸¸ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°çš„åŸå‹å¦‚ä¸‹ï¼š

```go
func panic(interface{})
func recover() interface{}
```

å½“åœ¨ä¸€ä¸ªå‡½æ•°ä¸­è°ƒç”¨ `panic()` æ—¶ï¼Œæ­£å¸¸çš„å‡½æ•°æ‰§è¡Œæµç¨‹å°†ç«‹å³ç»ˆæ­¢ï¼Œä½†å‡½æ•°ä¸­ä¹‹å‰ä½¿ç”¨ `defer` å…³é”®å­—å»¶è¿Ÿæ‰§è¡Œçš„è¯­å¥å°†æ­£å¸¸å±•å¼€æ‰§è¡Œï¼Œä¹‹åè¯¥å‡½æ•°å°†è¿”å›åˆ°è°ƒç”¨å‡½æ•°ï¼Œå¹¶å¯¼è‡´é€å±‚å‘ä¸Šæ‰§è¡Œ `panic()` æµç¨‹ï¼Œç›´è‡³æ‰€å±çš„ `goroutine` ä¸­æ‰€æœ‰æ­£åœ¨æ‰§è¡Œçš„å‡½æ•°è¢«ç»ˆæ­¢ã€‚é”™è¯¯ä¿¡æ¯å°†è¢«æŠ¥å‘Šï¼ŒåŒ…æ‹¬åœ¨è°ƒç”¨ `panic()` å‡½æ•°æ—¶ä¼ å…¥çš„å‚æ•°ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºé”™è¯¯æµç¨‹å¤„ç†ã€‚

`panic()` æ¥å—ä¸€ä¸ª `interface{}` å‚æ•°ï¼Œå¯æ”¯æŒä»»æ„ç±»å‹ï¼Œä¾‹å¦‚ï¼š

```go
panic(404)
panic("network broken")
panic(Error("file not exists"))
```

åœ¨ `defer` è¯­å¥ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `recover()` ç»ˆæ­¢é”™è¯¯å¤„ç†æµç¨‹ï¼Œè¿™æ ·å¯ä»¥é¿å…å¼‚å¸¸å‘ä¸Šä¼ é€’ï¼Œä½†è¦æ³¨æ„ `recover()` ä¹‹åï¼Œç¨‹åºä¸ä¼šå†å›åˆ° `panic()` é‚£é‡Œï¼Œå‡½æ•°ä»åœ¨ `defer` ä¹‹åè¿”å›ã€‚æ–°å»ºä¸€ä¸ªæºæ–‡ä»¶ `error1.go`ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

```go
func foo() {
    panic(errors.New("i'm a bug"))
    return
}

func test() (result int) {
    defer func() {
        if r := recover(); r != nil {
            err := r.(error)
            fmt.Println("Cache Exception:", err)
        }
    }()
    foo()
    return 10
}

func main() {
    fmt.Println(test())     // 0
}
```

## é¢å‘å¯¹è±¡ç¼–ç¨‹

### è‡ªå®šä¹‰ç±»å‹

Go è¯­è¨€çš„ä¸­ç»“æ„ä½“ `struct` ä¸ C++ã€JAVA ä¸­çš„ç±» `class` ç›¸ä¼¼ï¼Œä½† Go æ”¾å¼ƒäº†ä¼ ç»Ÿé¢å‘å¯¹è±¡çš„è¯¸å¤šç‰¹æ€§ï¼Œåªä¿ç•™äº†ç»„åˆã€‚

- **type** typeName typeSpecification

å…¶ä¸­ï¼Œ`typeName` å¯ä»¥æ˜¯ä¸€ä¸ªåŒ…æˆ–è€…å‡½æ•°å†…å”¯ä¸€åˆæ³•çš„ Go æ ‡ç¤ºç¬¦ã€‚`typeSpecification` å¯ä»¥æ˜¯ä»»ä½•å†…ç½®çš„ç±»å‹ï¼Œä¸€ä¸ªæ¥å£æˆ–è€…æ˜¯ä¸€ä¸ªç»“æ„ä½“ã€‚æ‰€è°“ç»“æ„ä½“ï¼Œå®ƒçš„å­—æ®µæ˜¯ç”±å…¶ä»–ç±»å‹æˆ–è€…æ¥å£ç»„æˆã€‚ä¾‹å¦‚æˆ‘ä»¬é€šè¿‡ç»“æ„ä½“å®šä¹‰äº†ä¸€ä¸‹ç±»å‹ï¼š

```go
type ColorPoint struct {
    color.Color     // åŒ¿åå­—æ®µ(åµŒå…¥)
    x, y int        // å…·åå­—æ®µ(èšåˆ)
}
```

ä»¥ä¸Šä»£ç æˆ‘ä»¬é€šè¿‡ç»“æ„ä½“è‡ªå®šä¹‰äº†ç±»å‹ `ColorPoint`ï¼Œç»“æ„ä½“ä¸­ `color.Color` å­—æ®µæ˜¯ Color åŒ…çš„ç±»å‹ colorï¼Œè¿™ä¸ªå­—æ®µæ²¡æœ‰åå­—ï¼Œæ‰€ä»¥è¢«ç§°ä¸ºåŒ¿åçš„ï¼Œä¹Ÿæ˜¯åµŒå…¥å­—æ®µã€‚å­—æ®µ `x` å’Œ `y` æ˜¯æœ‰å˜é‡åçš„ï¼Œæ‰€ä»¥è¢«ç§°ä¸ºå…·åå­—æ®µã€‚å‡å¦‚æˆ‘ä»¬åˆ›å»ºäº†ç±»å‹ `ColorPoint` çš„ä¸€ä¸ªå€¼ `point`ï¼ˆé€šè¿‡è¯­æ³•ï¼š`point := ColorPoint{}` åˆ›å»ºï¼‰ï¼Œé‚£ä¹ˆè¿™äº›å­—æ®µå¯ä»¥é€šè¿‡ `point.Color`ã€`point.x`ã€`point.y` è®¿é—®ã€‚å…¶ä»–é¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„"ç±» (`class`)"ã€"å¯¹è±¡ (`object`)"ã€"å®ä¾‹ (`instance`)"åœ¨ Go è¯­è¨€ä¸­æˆ‘ä»¬å®Œå…¨é¿å¼€ä½¿ç”¨ã€‚ç›¸åçš„æˆ‘ä»¬ä½¿ç”¨"ç±»å‹ (`type`)"å’Œå…¶å¯¹åº”çš„"å€¼"ï¼Œå…¶ä¸­è‡ªå®šä¹‰ç±»å‹çš„å€¼å¯ä»¥åŒ…å«æ–¹æ³•ã€‚

å®šä¹‰äº†ç»“æ„ä½“åå¦‚ä½•åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡å®ä¾‹å‘¢ï¼ŸGo è¯­è¨€æ”¯æŒä»¥ä¸‹å‡ ç§æ–¹æ³•è¿›è¡Œå®ç°ï¼š

```go
//å…ˆå®šä¹‰ä¸€ä¸ªç»“æ„ä½“Man
type Man struct{
    name string
    age int
}
//å¯¹è±¡åˆ›å»ºä¸åˆå§‹åŒ–
man := new(Man)
man := &Man{}
man := &Man{"Tom", 18}
man := &Man{name: "Tom", age: 18}
```

ä¸ºäº†æ›´åŠ æ–¹ä¾¿çš„åˆ›å»ºå¯¹è±¡ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¼šä½¿ç”¨ä¸€ä¸ªå…¨å±€å‡½æ•°æ¥å®Œæˆå¯¹è±¡çš„åˆ›å»ºï¼Œè¿™å’Œä¼ ç»Ÿçš„â€œæ„é€ å‡½æ•°â€ç±»ä¼¼ã€‚

```go
func NewMan(name string, age int) *Man {
    return &Man{name, age}
}
```

### æ–¹æ³•

æ–¹æ³•æ˜¯ä½œç”¨åœ¨è‡ªå®šä¹‰ç±»å‹ä¸Šçš„ä¸€ç±»ç‰¹æ®Šå‡½æ•°ï¼Œé€šå¸¸è‡ªå®šä¹‰ç±»å‹çš„å€¼ä¼šè¢«ä¼ é€’ç»™è¯¥å‡½æ•°ï¼Œè¯¥å€¼å¯èƒ½æ˜¯ä»¥æŒ‡é’ˆæˆ–è€…å¤åˆ¶å€¼çš„å½¢å¼ä¼ é€’ã€‚å®šä¹‰æ–¹æ³•å’Œå®šä¹‰å‡½æ•°å‡ ä¹ç›¸åŒï¼Œåªæ˜¯éœ€è¦åœ¨ `func` å…³é”®å­—å’Œæ–¹æ³•åä¹‹é—´å¿…é¡»å†™ä¸Šæ¥æ¥å—è€…ã€‚ä¾‹å¦‚æˆ‘ä»¬ç»™ç±»å‹ `Count` å®šä¹‰äº†ä»¥ä¸‹æ–¹æ³•ï¼š

```go
type Count int

func (count *Count) Increment() { *count++ }  // æ¥å—è€…æ˜¯ä¸€ä¸ª `Count` ç±»å‹çš„æŒ‡é’ˆ
func (count *Count) Decrement() { *count-- }
func (count Count) IsZero() bool { return count == 0 }
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬åœ¨å†…ç½®ç±»å‹ `int` çš„åŸºç¡€ä¸Šå®šä¹‰äº†è‡ªå®šä¹‰ç±»å‹ `Count`ï¼Œç„¶åç»™è¯¥ç±»å‹æ·»åŠ äº† `Increment()`ã€`Decrement()` å’Œ `IsZero()` æ–¹æ³•ï¼Œå…¶ä¸­å‰ä¸¤è€…çš„æ¥å—è€…ä¸º `Count` ç±»å‹çš„æŒ‡é’ˆï¼Œåä¸€ä¸ªæ–¹æ³•æ¥æ”¶ `Count` ç±»å‹çš„å€¼ã€‚

ç±»å‹çš„æ–¹æ³•é›†æ˜¯æŒ‡å¯ä»¥è¢«è¯¥ç±»å‹çš„å€¼è°ƒç”¨çš„æ‰€æœ‰æ–¹æ³•çš„é›†åˆã€‚

ä¸€ä¸ªæŒ‡å‘è‡ªå®šä¹‰ç±»å‹çš„å€¼çš„æŒ‡é’ˆï¼Œå®ƒçš„æ–¹æ³•é›†ç”±è¯¥ç±»å‹å®šä¹‰çš„æ‰€æœ‰æ–¹æ³•ç»„æˆï¼Œæ— è®ºè¿™äº›æ–¹æ³•æ¥å—çš„æ˜¯ä¸€ä¸ªå€¼è¿˜æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚å¦‚æœåœ¨æŒ‡é’ˆä¸Šè°ƒç”¨ä¸€ä¸ªæ¥å—å€¼çš„æ–¹æ³•ï¼ŒGo è¯­è¨€ä¼šèªæ˜åœ°å°†è¯¥æŒ‡é’ˆè§£å¼•ç”¨ã€‚

ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹å€¼çš„æ–¹æ³•é›†åˆåˆ™ç”±è¯¥ç±»å‹å®šä¹‰çš„æ¥æ”¶è€…ä¸ºå€¼ç±»å‹çš„æ–¹æ³•ç»„æˆï¼Œä½†æ˜¯ä¸åŒ…æ‹¬é‚£äº›æ¥æ”¶è€…ç±»å‹ä¸ºæŒ‡é’ˆçš„æ–¹æ³•ã€‚

å…¶å®è¿™äº›é™åˆ¶ Go è¯­è¨€å¸®æˆ‘ä»¬è§£å†³çš„éå¸¸å¥½ï¼Œç»“æœå°±æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨å€¼ç±»å‹ä¸Šè°ƒç”¨æ¥æ”¶è€…ä¸ºæŒ‡é’ˆçš„æ–¹æ³•ã€‚å‡å¦‚æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå€¼ï¼Œä»ç„¶å¯ä»¥è°ƒç”¨ä¸€ä¸ªæ¥æ”¶è€…ä¸ºæŒ‡é’ˆç±»å‹çš„æ–¹æ³•ï¼Œè¿™æ˜¯å› ä¸º Go è¯­è¨€ä¼šè‡ªåŠ¨è·å–å€¼çš„åœ°å€ä¼ é€’ç»™è¯¥æ–¹æ³•ï¼Œå‰ææ˜¯è¯¥å€¼æ˜¯å¯å¯»å€çš„ã€‚

åœ¨ä»¥ä¸Šå®šä¹‰çš„ç±»å‹ `Count` ä¸­ï¼Œ`*Count` æ–¹æ³•é›†æ˜¯ `Increment()`, `Decrement()` å’Œ `IsZero()`ï¼Œ`Count` çš„å€¼çš„æ–¹æ³•é›†æ˜¯ `IsZero()`ã€‚ä½†æ˜¯å› ä¸º `Count` ç±»å‹çš„æ˜¯å¯å¯»å€çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Count` çš„å€¼è°ƒç”¨å…¨éƒ¨çš„æ–¹æ³•ã€‚

å¦å¤–å¦‚æœç»“æ„ä½“çš„å­—æ®µä¹Ÿæœ‰æ–¹æ³•ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥é€šè¿‡ç»“æ„ä½“è®¿é—®å­—æ®µä¸­çš„æ–¹æ³•ã€‚ä¸‹é¢è®©æˆ‘ä»¬ç»ƒä¹ ä¸‹ï¼Œåˆ›å»ºæºæ–‡ä»¶ `struct_t.go`ï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

```go
package main

import "fmt"

type Count int // åˆ›å»ºè‡ªå®šä¹‰ç±»å‹ Count

func (count *Count) Increment()  { *count++ } // Countç±»å‹çš„æ–¹æ³•
func (count *Count) Decrement()  { *count-- }
func (count Count) IsZero() bool { return count == 0 }

type Part struct { // åŸºäºç»“æ„ä½“åˆ›å»ºè‡ªå®šä¹‰ç±»å‹ Part
    stat  string
    Count // åŒ¿åå­—æ®µ
}

func (part Part) IsZero() bool { // è¦†ç›–äº†åŒ¿åå­—æ®µCountçš„IsZero()æ–¹æ³•
    return part.Count.IsZero() && part.stat == "" // è°ƒç”¨äº†åŒ¿åå­—æ®µçš„æ–¹æ³•
}

func (part Part) String() string { // å®šä¹‰String()æ–¹æ³•ï¼Œè‡ªå®šä¹‰äº†æ ¼å¼åŒ–æŒ‡ä»¤%vçš„è¾“å‡º
    return fmt.Sprintf("<<%s, %d>>", part.stat, part.Count)
}

func main() {
    var i Count = -1
    fmt.Printf("Start \"Count\" test:\nOrigin value of count: %d\n", i)
    i.Increment()
    fmt.Printf("Value of count after increment: %d\n", i)
    fmt.Printf("Count is zero t/f? : %t\n\n", i.IsZero())
    fmt.Println("Start: \"Part\" test:")
    part := Part{"232", 0}
    fmt.Printf("Part: %v\n", part)
    fmt.Printf("Part is zero t/f? : %t\n", part.IsZero())
    fmt.Printf("Count in Part is zero t/f?: %t\n", part.Count.IsZero()) // å°½ç®¡è¦†ç›–äº†åŒ¿åå­—æ®µçš„æ–¹æ³•ï¼Œå•è¿˜æ˜¯å¯ä»¥è®¿é—®

}
```

ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº† `Count` ç±»å‹ï¼Œç„¶ååœ¨å…¶åŸºç¡€ä¸Šåˆåˆ›å»ºäº†ç»“æ„ä½“ç±»å‹ `Part`ã€‚æˆ‘ä»¬ä¸º `Count` ç±»å‹å®šä¹‰äº† 3 ä¸ªæ–¹æ³•ï¼Œå¹¶åœ¨ `Part` ç±»å‹ä¸­åˆ›å»ºäº†æ–¹æ³• `IsZero()` è¦†ç›–äº†å…¶åŒ¿åå­—æ®µ `Count` ä¸­ `IsZero()` æ–¹æ³•ã€‚ä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥äºŒæ¬¡è®¿é—®åˆ°åŒ¿åå­—æ®µä¸­è¢«è¦†ç›–çš„æ–¹æ³•ã€‚æ‰§è¡Œä»£ç ï¼Œè¾“å‡ºå¦‚ä¸‹ï¼š

```bash
$ go run struct_t.go
Start "Count" test:


Origin value of count: -1
Value of count after increment: 0
Count is zero t/f? : true

Start: "Part" test:
Part: <<232, 0>>
Part is zero t/f? : false
Count in Part is zero t/f?: true
```



